hub:
  service:
    type: ClusterIP
  extraVolumes: 
    - name: uitemplates-azurefiles
      persistentVolumeClaim:
        claimName: uitemplates-azurefiles
  extraVolumeMounts:
    - name: uitemplates-azurefiles
      mountPath: /jupyter/uitemplates
  extraConfig:    
    00-first-config: |
      import json
      import jwt
      import os
      import urllib
      import requests

      from tornado import gen
      from tornado.auth import OAuth2Mixin
      from tornado.log import app_log
      from tornado.httpclient import HTTPRequest, AsyncHTTPClient
      from oauthenticator.azuread import AzureAdOAuthenticator
      from traitlets import Unicode, default
      from oauthenticator.oauth2 import OAuthLoginHandler, OAuthenticator

      class CustomAzureADAuthenticator(AzureAdOAuthenticator):
        
          login_service = Unicode(
            os.environ.get('LOGIN_SERVICE', 'Z2JH'),
            config=True,
            help="""Login with your Azure organization credentials"""
          )

          tenant_id = Unicode(config=True, help="The Azure Active Directory Tenant ID")

          @default('tenant_id')
          def _tenant_id_default(self):
              return os.environ.get('AAD_TENANT_ID', '')

          username_claim = Unicode(config=True)

          # use the v2 version of the authorization as it allows custom claim mapping.
          # https://d1ocs.microsoft.com/en-us/azure/active-directory/develop/active-directory-claims-mapping#example-create-and-assign-a-policy-to-include-the-employeeid-and-tenantcountry-as-claims-in-tokens-issued-to-a-service-principal
          @default("authorize_url")
          def _authorize_url_default(self):
            return 'https://login.microsoftonline.com/{0}/oauth2/v2.0/authorize'.format(self.tenant_id)

          # use the v2 version of the token as it allows custom claim mapping.
          # https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-claims-mapping#example-create-and-assign-a-policy-to-include-the-employeeid-and-tenantcountry-as-claims-in-tokens-issued-to-a-service-principal
          @default("token_url")
          def _token_url_default(self):
            return 'https://login.microsoftonline.com/{0}/oauth2/v2.0/token'.format(self.tenant_id)
          
          # the v2 version of the APIs requires a scope.
          # https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-claims-mapping#example-create-and-assign-a-policy-to-include-the-employeeid-and-tenantcountry-as-claims-in-tokens-issued-to-a-service-principal
          @default("scope")
          def _scope(self):
            return ['openid']
          
          @default('username_claim')
          def _username_claim_default(self):
            return 'onpremisessamaccountname'

          def get_decoded_token(self, token):
            AZURE_AD_OPEN_ID_CONFIGURATION_URL = \
            "https://login.microsoftonline.com/{}/v2.0/.well-known/openid-configuration?appid={}" \
            .format(self.tenant_id,self.client_id)
            # self.log.info("AZURE_AD_OPEN_ID_CONFIGURATION_URL: %s" % AZURE_AD_OPEN_ID_CONFIGURATION_URL)
            res = requests.get(AZURE_AD_OPEN_ID_CONFIGURATION_URL)
            jwk_keys = requests.get(res.json()["jwks_uri"]).json()

            public_keys = {}
            for jwk in jwk_keys['keys']:
                kid = jwk['kid']
                public_keys[kid] = jwt.algorithms.RSAAlgorithm.from_jwk(json.dumps(jwk))
            try:
              kid = jwt.get_unverified_header(token)['kid']
              public_key = public_keys[kid]

              # self.log.info("token: %s" % token)
              algorithm = ['RS256']
              decoded = jwt.decode(token,
                                  key=public_key,
                                  algorithm=algorithm,
                                  audience=self.client_id)
            except jwt.exceptions.DecodeError as dex:
              # import traceback
              # exc_type, exc_value, exc_traceback = sys.exc_info()
              # traceback.print_tb(exc_traceback, limit=None, file=sys.stdout)
              # decoded = jwt.decode(token,verify=False)
              # self.log.info("Error in decoding token: %s " % str(dex))
              raise dex
            return decoded

          async def authenticate(self, handler, data=None):
            # userdict = await super().authenticate(handler, data)
            # default name from Azure AD can contain spaces and messes up container names. Use the onpremisessamaccountname.
            # onpremisessamaccountname is in the format some.thing so remove any dots in the name
            
            code = handler.get_argument("code")                            
            http_client = AsyncHTTPClient()

            params = dict(
                client_id=self.client_id,
                client_secret=self.client_secret,
                grant_type='authorization_code',
                code=code,
                redirect_uri=self.get_callback_url(handler))

            data = urllib.parse.urlencode(
                params, doseq=True, encoding='utf-8', safe='=')

            url = self.token_url
            # self.log.info('authenticate token_url:%s' % self.token_url)
            headers = {
                'Content-Type':
                'application/x-www-form-urlencoded; charset=UTF-8'
            }
            req = HTTPRequest(
                url,
                method="POST",
                headers=headers,
                body=data  # Body is required for a POST...
            )

            resp = await http_client.fetch(req)
            resp_json = json.loads(resp.body.decode('utf8', 'replace'))

            # self.log.info("Response %s", resp_json)
            # Ignore the access_token for now as its not used. 
            # If you decide to use it later then you need to verify it first.
            # access_token = resp_json['access_token']

            id_token = resp_json['id_token']            
            decoded = self.get_decoded_token(id_token)

            self.log.info('authenticate decoded:%s' % decoded)

            userdict = {"name": decoded[self.username_claim].replace('.','')}
            userdict["auth_state"] = auth_state = {}
            # auth_state['access_token'] = access_token
            # results in a decoded JWT for the user data
            auth_state['user'] = decoded

            return userdict

          @gen.coroutine
          def pre_spawn_start(self, user, spawner):
              auth_state = yield user.get_auth_state()
              
              # this is a terrible idea to log auth_state so do NOT do it in production.
              # it super useful to debug but a big security hole.
              # comment or remove the next line when deploying to production
              # self.log.info('pre_spawn_start auth_state:%s' % auth_state)           
              # self.log.info('pre_spawn_start user name: %s' % user.name)

              # get the username to send to the NB_USER environment variable. 
              # this becomes the username in the container.
              nb_user = user.name
              
              # get the UID and GID from the Azure Active Directory roles field. 
              # see https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-add-app-roles-in-azure-ad-apps
              # in this sample the roles are of the format ['uid,gid'] so we parse it to extract the uid and gid.
              # app role assignment can be done in Azure AD using Azure portal.
              # to force a user to have access set user assignment required in the AD application https://docs.microsoft.com/en-us/azure/active-directory/manage-apps/assign-user-or-group-access-portal#configure-an-application-to-require-user-assignment
              # to make this production grade update the code below to check for the roles attribute otherwise provide a default value.
              nb_uid = "1000" # default uid
              nb_gid = "500" # primary group id
              nb_ogid = "1000" # other gid
              if 'roles' in auth_state['user']: # this is defensive in case user assignment required is not set
                nb_user_roles = auth_state['user']['roles'][0].split(',')
                # self.log.info('pre_spawn_start nb_user_roles: %s' % str(nb_user_roles))
                nb_uid = nb_user_roles[0]
                nb_gid = nb_user_roles[1]
                nb_ogid = nb_user_roles[2]
                # log only for debugging. comment out for production
              # else:
              #   self.log.info('No roles in auth_state using default roles')
              # Disable the next set of log lines in production
              # self.log.info('pre_spawn_start NB_USER: %s' % str(nb_user))
              # self.log.info('pre_spawn_start NB_UID: %s' % str(nb_uid))
              # self.log.info('pre_spawn_start NB_GID: %s' % str(nb_gid))
              # self.log.info('pre_spawn_start NB_OGID: %s' % str(nb_ogid))
              spawner.environment['NB_USER'] = nb_user
              spawner.environment['NB_UID'] = nb_uid
              spawner.environment['NB_GID'] = nb_gid
              spawner.environment['NB_OGID'] = nb_ogid              
      c.JupyterHub.authenticator_class = CustomAzureADAuthenticator
      c.Spawner.notebook_dir = '/home/{username}' # start the notebook in the user folder
      c.KubeSpawner.cmd = 'start-singleuser.sh' # call the cmd as you need to pass the argument below
      c.KubeSpawner.args = ['--allow-root'] # this is a MUST to use the NB_USER, NB_UID and NB_GID to set username, uid and gid in the container
      c.JupyterHub.template_paths = ['/jupyter/uitemplates']
      c.JupyterHub.template_vars = {'announcement': 'You are seeing a private preview of this service. This is not for production use yet.'}
      c.JupyterHub.logo_file = '/jupyter/uitemplates/logo.svg'
proxy:
  secretToken: "{{SECRET_TOKEN}}"
  service:
    type: ClusterIP #https://gist.github.com/manics/c4bcf53a210d444db9e64db7673e8580
auth:
  state:
    enabled: true # this is required to get the auth_state which has the roles from Azure AD.
    cryptoKey: "{{CRYPTO_KEY}}"
  type: azuread
  azuread:
    clientId: "{{CLIENT_ID}}"
    clientSecret: "{{CLIENT_SECRET}}"
    tenantId: "{{TENANT_ID}}"
    callbackUrl: "http://localhost/hub/oauth_callback" # must match the Azure AD application redirect url    
  admin:
    users:
      - {{ADMIN_USER}}
    access: false
ingress:
  enabled: true
  hosts:
    - localhost # set this to the host that will be used by the end users to access this service https://zero-to-jupyterhub.readthedocs.io/en/latest/administrator/advanced.html#ingress
singleuser:
  uid: 0 # absolute MUST to use the NB_USER, NB_UID and NB_GID to set username, uid and gid in the container
  defaultUrl: "/lab"
  image:
    name: custom-notebook
    tag: v1
  profileList:
    - display_name: "Standard environment"
      description: "The standard environment. Min: 0.5 CPU & Max: 2 CPU and Min 512M RAM & Max: 2GB RAM."
      default: true
      kubespawner_override:
        cpu_guarantee: 0.5
        mem_guarantee: 512M
        cpu_limit: 2
        mem_limit: 2G
    - display_name: "Advanced environment"
      description: "The standard environment. Min: 2 CPU & Max: 4 CPU and Min 2GB RAM & Max: 4GB RAM."
      kubespawner_override:
        image: custom-notebook:v1
        cpu_guarantee: 2
        mem_guarantee: 2G
        cpu_limit: 4
        mem_limit: 4G
    - display_name: "ML environment"
      description: "The standard environment. Min: 2 CPU & Max: 4 CPU and Min 2GB RAM & Max: 8GB RAM."
      kubespawner_override:
        image: custom-notebook:v1
        cpu_guarantee: 2
        mem_guarantee: 2G
        cpu_limit: 4
        mem_limit: 8G
        extra_resource_guarantees:
          nvidia.com/gpu: 2
  storage:
    type: "static"
    static:
      pvcName: users-azurefiles
      subPath: '{username}'
    homeMountPath: /home/{username}
    extraVolumes:
      - name: notebooks-azurefiles
        persistentVolumeClaim:
          claimName: notebooks-azurefiles
      - name: lmod-modules-azurefiles
        persistentVolumeClaim:
          claimName: lmod-modules-azurefiles
      - name: libs-azurefiles
        persistentVolumeClaim:
          claimName: libs-azurefiles
    extraVolumeMounts:
      - name: notebooks-azurefiles
        mountPath: /jupyter/notebooks
      - name: lmod-modules-azurefiles
        mountPath: /jupyter/lmod/modules
      - name: libs-azurefiles
        mountPath: /jupyter/libs
  extraEnv:
      JUPYTER_ALLOW_INSECURE_WRITES: '1' # https://github.com/jupyter/jupyter_core/pull/182/